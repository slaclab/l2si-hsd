#!/usr/bin/env python3
#-----------------------------------------------------------------------------
# This file is part of the 'Camera link gateway'. It is subject to
# the license terms in the LICENSE.txt file found in the top-level directory
# of this distribution and at:
#    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
# No part of the 'Camera link gateway', including this file, may be
# copied, modified, propagated, or distributed except according to the terms
# contained in the LICENSE.txt file.
#-----------------------------------------------------------------------------

import pyrogue as pr
import time

i2cSwitchPort = { 'PrimaryFmc':1, 'SecondaryFmc':2, 'SFP':4, 'LocalBus':8 }

class AxiLiteMasterProxy(pr.Device):
    def __init__(   self,
                    name        = "AxiLiteMasterProxy",
                    description = "Proxy for Axi-Lite transactions",
                    **kwargs):
        super().__init__(name=name, description=description, **kwargs)

        def addvar(name,offset,mode='RW'):
            self.add(pr.RemoteVariable(
                name     = name,
                offset   = offset,
                bitSize  = 32,
                mode     = mode,
                verify   = False))

        addvar('rnw' ,0x0)
        addvar('cmpl',0x4,'RO')
        addvar('addr',0x8)
        addvar('valu',0xc)

    def readI2c(self, offset):
        addr = offset + self._getAddress() - self._getOffset()
        self.addr.set(addr)
        self.rnw .set(1)
        self.wait_for_complete(f'readI2c reading {offset}')
        return self.valu.get()

    def writeI2c(self, offset, value):
        addr = offset + self._getAddress() - self._getOffset()
        self.valu.set(value)
        self.addr.set(addr)
        self.rnw .set(0)
        self.wait_for_complete(f'writeI2c writing {value} to  {offset}')

    def wait_for_complete(self,msg):
        tmo = 0
        tmo_mask = 3
        while(True):
            time.sleep(1.e-3)
            tmo += 1
            if (tmo&tmo_mask)==tmo_mask:
                tmo_mask = (tmo_mask<<1) | 1
                print(f'{msg}: tmo {tmo}')
            if (self.cmpl.get()&1) == 1:
                break

class FmcSpi(object):
    AD9517=1<<2
    ADC   =2<<2
    CPLD  =8<<2
    def __init__(self,proxy,offset):
        self.proxy= proxy
        self.reg  = offset
        self.sp1  = offset+0x400
        self.sp2  = offset+0x800

    def cpld_init(self):
        fans    = 0
        syncsrc = 1  # FPGA
        dirs    = 1
        clksrc  = 3  # ext ref

        self.resetSPIclocktree()
        self.resetSPIadc()

        self._writeAD9517(0,0x99)

        r0 = (clksrc&0x07)|((syncsrc&0x3)<<3)
        self._writeCPLD(0,r0)

        r1 = (dirs&0xf)|((fans&0xf)<<4)
        self._writeCPLD(1,r1)

        self._writeCPLD(2,0) # LED off

        v = self._readCPLD(0)
        if (v&0xff) != r0:
            raise ValueError('Error verifying reg0 {:x}:{:x}'.format(v&0xff,r0))
        print('CPLD r0 : {:x}'.format(v))
  
        v = self._readCPLD(1)
        if ((v&0xff) != r1):
            raise ValueError('Error verifying reg1 {:x}:{:x}'.format(v&0xff,r1))
        print('CPLD r1 : {:x}'.format(v))


    def clocktree_init(self, clksrc, vcotype, timing):
        if timing=='_119M':
            # 9.996 MHz refclk  (LCLS)
            # Gives 21 samples / 119MHz cycle (294 samples / 8.5MHz cycle)
            A = 4
            B = 78
            P = 6 # P-counter = 32
            R = 10
        elif timing=='_186M':
            # 14-6/7 MHz refclk (LCLSII) [929kHz * 16]
            # Gives 2696 samples / 929kHz beam cycle
            A = 21
            B = 52 # [ (52*32 + 21)/10 = 168.5 ]
            P = 6  # P-counter = 32
            R = 10
        elif timing=='_4M':
            # 4*929 kHz refclk (LCLSII)
            # Gives 674*4 / 929kHz beam cycle
            A = 2
            B = 21 # [ (21*32 + 2)/1 = 674 ]
            P = 6  # P-counter = 32
            R = 1
        else:
            raise ValueError(f'No match for timing [{timing}]')

        print(f'clocktree A={A}, B={B}, P={P}, R={R}')

        self._writeAD9517( 0x10, 0x7c) #CP 4.8mA, normal op.
        self._writeAD9517( 0x11, R)    #R lo
        self._writeAD9517( 0x12, 0x00) #R hi
        self._writeAD9517( 0x13, A) #A
        self._writeAD9517( 0x14, B) #B
        self._writeAD9517( 0x14, B) #B lo
        self._writeAD9517( 0x15, 0) #B hi
        self._writeAD9517( 0x16, P) #presc. DM16
        self._writeAD9517( 0x17, 0x84) #STATUS = DLD
        self._writeAD9517( 0x19, 0x00)
        self._writeAD9517( 0x1A, 0x00) #LD = DLD
        self._writeAD9517( 0x1B, 0x00) #REFMON = GND
        #  self._writeAD9517( 0x1C, 0x86) #REF1 input
        self._writeAD9517( 0x1C, 0x87) #Diff ref input
        self._writeAD9517( 0x1D, 0x00) 
        self._writeAD9517( 0xF0, 0x02) #out0, safe power down
        self._writeAD9517( 0xF1, 0x0C) #out1, lvpecl 960mW
        self._writeAD9517( 0xF4, 0x02) #out2, safe power down
        self._writeAD9517( 0xF5, 0x0C) #out3, adc, lvpecl 960mW
        self._writeAD9517(0x140, 0x01) #out4, sync, pd
        self._writeAD9517(0x141, 0x01) #out5, pd
        self._writeAD9517(0x142, 0x00) #out6, lvds 1.75mA
        self._writeAD9517(0x143, 0x01) #out7, pd
        self._writeAD9517(0x190, 0xBC) #div0, clk out, /50 (50MHz)
        self._writeAD9517(0x191, 0x00) #div0, clk out, divider used
        self._writeAD9517(0x192, 0x00) #div0, clk out, divider to output
        self._writeAD9517(0x196, 0x22) #div1, adc, /2
        self._writeAD9517(0x197, 0x80) #div1, adc, divider bypassed
        self._writeAD9517(0x198, 0x02) #div1, adc, clk to output
        self._writeAD9517(0x199, 0x00) #div2.1, /2
        self._writeAD9517(0x19A, 0x00) #phase
        self._writeAD9517(0x19B, 0x00) #div2.2, /2
        self._writeAD9517(0x19C, 0x00) #div2.1 on, div2.2 on
        self._writeAD9517(0x19D, 0x00) #div2 dcc on
        self._writeAD9517(0x19E, 0x11) #div3.1, /4
        self._writeAD9517(0x19F, 0x00) #phase
        self._writeAD9517(0x1A0, 0x00) #div3.2, /2
        self._writeAD9517(0x1A1, 0x00) #div3.1 on, div3.2 on
        self._writeAD9517(0x1A2, 0x00) #div3 dcc on
        self._writeAD9517(0x1E0, 0x00) #vco div /2

        self._writeAD9517(0x1E1, 0x00) #user external vco and vco divider

        self._writeAD9517(0x230, 0x00) #no pwd, no sync
        self._writeAD9517(0x232, 0x01) #update 
  
        time.sleep(0.1)
  
        # verify CLK0 PLL status
        v = self._readAD9517(0x1F)
        if ((v&0x01)!=0x01):
            raise ValueError("PLL not locked!!!")
        print("PLL locked!!!")

        self._clockWhileSync()


    def adc_enable_test(self, pattern):
        d = {'Ramp':0, 'Flash11':1, 'Flash12':3, 'Flash16':5, 'DMA':8}

        if pattern not in d:
            raise ValueError('Pattern {pattern} not recognized: {d}')

        dp = d[pattern]

        self.proxy.writeI2c(self.reg+4*0xf0,3)
        time.sleep(0.01)
        
        v = self._readADC(0)
        print(f'ADC  partId = {v}')

        v = self._readADC(2)
        print('Active channels {:x}'.format(v&0xf))

        self._writeADC(5,dp)
        v = self._readADC(5)
        print(f'Enable pattern {v}')

        if v!=dp:
            raise ValueError(f'adc_enable_test read pattern {v}[{dp}]')
            
        v = self._readADC(1)
        v |= (1<<12)
        self._writeADC(1,v)
        v = self._readADC(1)
        if ((v>>12)&1)!=1:
            raise ValueError('adc_enable_test read reg1 {:x}[{:x}'.
                             format(v,(1<<12)))
                
        self._applySync();

    def adc_disable_test(self):
        v = self._readADC(1)
        v &= ~(1<<12)
        self._writeADC(1,v);

        v = self._readADC(1)
        if ((v>>12)&1)!=0:
            print('Error confirming disable {:x}:{:x}'.format(v,0))
            raise ValueError('adc_disable_test failed for FMC card')

    def resetSPIclocktree(self):
        v = self._readCPLD(0)
        self._writeCPLD(0,v|0x20)
        self._writeCPLD(0,v&~0x20)

    def resetSPIadc(self):
        v = self._readCPLD(0)
        self._writeCPLD(0,v|0x40)
        self._writeCPLD(0,v&~0x40)

    def _applySync(self):
        #  Apply sync
        v = self._readCPLD(0)
        v &= ~0x10
        self._writeCPLD(0,v)
        time.sleep(0.05)

        q = v
        v = self._readCPLD(0)
        v = q | 0x10
        self._writeCPLD(0,v)
        time.sleep(0.05)

        v = self._readCPLD(0)

    def _clockWhileSync(self):
        v = self._readADC(1)
        v |= (1<<10)
        self._writeADC(1,v)
        v = 1;
        self._writeADC(6,v)

    def _writeCPLD(self, reg, val):
        v = (val&0xff)<<8 | (reg&0x7f)
        self.proxy.writeI2c(self.sp1+self.CPLD,v)
        time.sleep(0.01)

    def _readCPLD(self, reg):
        v = (reg&0x7f) | (0xFF)<<8 | 0x80
        self.proxy.writeI2c(self.sp1+self.CPLD,v)
        time.sleep(0.01)

        v = self.proxy.readI2c(self.sp1)
        return (v>>8)&0xff

    def _writeAD9517(self, addr, val):
        v = (val&0xff)<<16 | ((addr&0xff)<<8) | ((addr&0x1f00)>>8)
        self.proxy.writeI2c(self.sp2+self.AD9517,v)
        time.sleep(0.01)

    def _readAD9517(self, addr):
        v = (0x80) | ((addr&0x1f00)>>8) | ((addr&0xff)<<8) | (0xFF)<<16
        self.proxy.writeI2c(self.sp2+self.AD9517,v)
        time.sleep(0.01)

        v = self.proxy.readI2c(self.sp2)
        v >>= 16
        v &= 0xff
        return v

    def _writeADC(self, addr, val):
        v = ((val&0xff)<<16) | (val&0xff00) | (addr&0x7f) | 0x80
        a = self.sp2+self.ADC
        self.proxy.writeI2c(a,v)
        time.sleep(0.01)

    def _readADC(self, addr):
        v = (addr&0x7f) | ((0xFFFF)<<8)
        self.proxy.writeI2c(self.sp2+self.ADC,v)
        time.sleep(0.01)

        v = self.proxy.readI2c(self.sp2)
        return ((v&0xff0000)>>16) | ((v&0xff00)>>0)


class Tps2481(object):
    def __init__(self,proxy,offset):
        self.proxy= proxy
        self.cfg  = offset+0x00
        self.shtv = offset+0x04
        self.busv = offset+0x08
        self.pwr  = offset+0x0c
        self.cur  = offset+0x10
        self.cal  = offset+0x14

    def start(self):
        self.proxy.writeI2c(self.cal,0x0010)

    def power_W(self):
        v = self.proxy.readI2c(self.pwr)
        print(f'power_W {v}')
        time.sleep(1.e-3)
        return ((v>>8)|((v&0xff)<<8))*400.e-6

    def current_A(self):
        v = self.proxy.readI2c(self.cur)
        time.sleep(1e-3)
        return ((v>>8)|((v&0xff)<<8))*20.e-6
        
class Adt7411(object):
    def __init__(self,proxy,offset):
        self.proxy  = proxy
        self.offset = offset

    def start(self):
        self.proxy.writeI2c(self.offset+4*0x18,9)
        self.proxy.writeI2c(self.offset+4*0x19,0)

        print('deviceId {:x}'.
              format(self.proxy.readI2c(self.offset+4*0x4d)))
        print('manufacturerId {:x}'.
              format(self.proxy.readI2c(self.offset+4*0x4e)))

    def mon(self):
        r = [0]*128
        ain = [0]*8
        for i in range(128):
            r[i] = self.proxy.readI2c(self.offset+4*i)&0xff
            time.sleep(1.e-3)

        v = r[3]
        Tint = (v>>0)&3
        Vdd  = (v>>2)&3

        v = r[4]
        Text = (v>>0)&3
        ain[0] = (v>>0)&3
        ain[1] = (v>>2)&3
        ain[2] = (v>>4)&3
        ain[3] = (v>>6)&3
  
        v = r[5]
        ain[4] = (v>>0)&3
        ain[5] = (v>>2)&3
        ain[6] = (v>>4)&3
        ain[7] = (v>>6)&3

        Vdd  |= (r[6]<<2)&0x3fc
        Tint |= (r[7]<<2)&0x3fc
        Text |= (r[8]<<2)&0x3fc

        for i in range(8):
            v = r[8+i]
            ain[i] |= (v<<2)&0x3fc

        d = {}
        d['Tint'] = (Tint<<22)*0.25/(1<<22)
        d['Text'] = (Text<<22)*0.25/(1<<22)
        d['Vdd' ] = (Vdd)*3.11*2.197e-3
        d['ain' ] = [0.]*8
        for i in range(8):
            d['ain'][i] = ain[i]*2.197e-3
        return d

class I2cMux(object):
    def __init__(self,proxy,offset):
        self.proxy  = proxy
        self.offset = offset

    def setPort(self, arg):
        self.proxy.writeI2c(self.offset,arg)

class ClkSynth(object):
    def __init__(self,proxy,offset):
        self.proxy  = proxy
        self.offset = offset

    def setTimingClk(self, arg):
        LOS_MASK  = 0x04
        LOCK_MASK = 0x15

        enable_mask = [
            0x00,0x00,0x00,0x00,0x00,0x00,0x1D,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0x1f,0x1f,0x1f,0x1f,
            0xff,0x7f,0x3f,0x00,0x00,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0x3f,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0x3f,0x7f,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0x3f,0x7f,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0x3f,0x00,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xbf,0xff,0x7f,0xff,
            0xff,0xff,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0f,
            0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x0f,0x0f,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,
            0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0xff,0x02,0x00,0x00,0x00,0xff,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0f,
            0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0x0f,0x00,0x00,0x00,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
            0xff,0x0f,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,
            0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0f,0x00,0x00,
            0x00]

        wr_values_119M = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x70, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x03, 0x42, 
            0xB0, 0xC4, 0xC4, 0xC4, 0xC4, 0x00, 0x06, 0x06, 0x06, 0x06, 
            0x63, 0x0C, 0x23, 0x00, 0x00, 0x00, 0x00, 0x14, 0x30, 0x10, 
            0xC5, 0x07, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 
            0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
            0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x99, 0x2D, 0x0C, 
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
            0xC0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x80, 0x00, 0xC0, 0x00, 
            0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x0D, 0x00, 0x00, 0xF4, 0xF0, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 
            0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 
            0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
            0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00]

        wr_values_186M = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x70, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x02, 0x42, 
            0xB0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x06, 0x06, 0x06, 0x06, 
            0x63, 0x0C, 0x23, 0x00, 0x00, 0x00, 0x00, 0x14, 0x35, 0x00, 
            0xC3, 0x07, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x01, 
            0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 
            0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x32, 0x00, 
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
            0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x40, 0x00, 
            0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x0D, 0x00, 0x00, 0xF4, 0xF0, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 
            0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 
            0x00, 0x84, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
            0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00]

        wr_values_64 = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x70, 0x0F, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x02, 0x42, 
            0xB0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x06, 0x06, 0x06, 0x06, 
            0x63, 0x0C, 0x23, 0x00, 0x00, 0x00, 0x00, 0x14, 0x35, 0x00, 
            0xC3, 0x07, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x01, 
            0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 0x10, 0x51, 0x06, 0x5C, 0x00, 0x00, 
            0x00, 0x19, 0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x32, 0x00, 
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
            0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x40, 0x00, 
            0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x0D, 0x00, 0x00, 0xF4, 0xF0, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 
            0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 
            0x00, 0x84, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
            0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x01, 0x00, 0x00, 0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x90, 0x31, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00]

        wr_values_arr = {'_119M':wr_values_119M, 
                         '_186M':wr_values_186M, 
                         '_4M'  :wr_values_64 }
        wr_values     = wr_values_arr[arg]

        def GET_REG(reg):
            addr = self.offset + 4*(reg&0xff)
            return self.proxy.readI2c(addr)&0xff

        def SET_REG(reg,value):
            t0 = GET_REG(reg)

            addr = self.offset + 4*(reg&0xff)
            self.proxy.writeI2c(addr,value&0xff)

            t1 = GET_REG(reg)

            print(f'Write [{reg}] {value} [{t0} -> {t1}]')

        def SET_FIELD(reg, value, shift, mask):
            w  = GET_REG(reg)
            w = w & ~(mask<<shift)
            w = w | ((value&mask)<<shift)
            SET_REG(reg,w)

        SET_REG(255,0)
        SET_FIELD(230,1,4,1) # Disable outputs Set OEB_All = 1 
        SET_REG(241,0xe5)    # Disable LOL

        #  Write the register map
        for i,v in enumerate(wr_values):
            if (i==230 or i==241 or i==246 or (enable_mask[i]==0)):
                continue
            if (i==255):
                SET_REG(i,1)
            else:
                r = self.offset+4*(i&0xff)
                v = self.proxy.readI2c(r)
                q = v & ~enable_mask[i]
                q |= wr_values[i]&enable_mask[i]
                SET_REG(i,q)

        SET_REG(255,0)

        #  Wait for input clock valid
        while( self.proxy.readI2c(self.offset+4*218)&LOS_MASK ):
            time.sleep(20.e-6)

        #  Configure PLL for locking
        SET_FIELD(49,0,7,1)

        #  Initiate locking of PLL (Soft Reset)
        SET_REG(246,2)

        time.sleep(50e-3)

        #  Restart LOL
        SET_REG(241,0x65)

        #  Wait for PLL to lock
        while True:
            print('wait for LOCK {:x}'.format(v))
            time.sleep(0.1)
            v = self.proxy.readI2c(self.offset+4*218)
            if (v&LOCK_MASK)==0:
                break

        #  Copy FCAL values
        SET_REG(45,GET_REG(235))
        SET_REG(46,GET_REG(236))

        SET_FIELD(47,(GET_REG(237)&3),0,3)
        SET_FIELD(47,0x3f,2,0x3f)
        #  SET_FIELD(47,0x05,2,0x3f)  # According to Ref Man

        #  Set PLL to use FCAL values
        SET_FIELD(49,1,7,1)

        #  Enable all outputs
        SET_FIELD(230,0,4,1) # Enable outputs; Set OEB_All = 0


class I2c126(pr.Device):
    def __init__(   self,
            name        = "PhaseDetector",
            description = "Measures the ADC-Timing clock phases",
            **kwargs):
        super().__init__(name=name, description=description, **kwargs)

        # I2CProxy
        self.add(AxiLiteMasterProxy(
            name   = "MasterProxy",
            offset = 0x0000_8000,
            expand = False ))
        
        def addvar(name):
            self.add(pr.LocalVariable(
                name        = name,
                description = name,
                mode        = 'RO',
                value       = 0,
            ))

        self.i2cmux       = I2cMux  (self.MasterProxy,0x0000)
        self.clksynth     = ClkSynth(self.MasterProxy,0x0400)

        self.vtmon1       = Adt7411 (self.MasterProxy,0x0C00)
        self.vtmon2       = Adt7411 (self.MasterProxy,0x1000)
        self.vtmon3       = Adt7411 (self.MasterProxy,0x1400)
        self.imona        = Tps2481 (self.MasterProxy,0x1800)
        self.imonb        = Tps2481 (self.MasterProxy,0x1C00)
        #self.vtmona       = 0x2000
        self.FmcSpi       = FmcSpi  (self.MasterProxy,0x2400)

        addvar('local12v')
        addvar('edge12v')
        addvar('aux12v')
        addvar('boardTemp')
        addvar('local1_8v')
        addvar('fmc12v')
        addvar('local2_5v')
        addvar('local3_3v')
        addvar('fmcPower')
        addvar('totalPower')

        @self.command()
        def start_env():
            self.i2cmux.setPort(i2cSwitchPort['LocalBus'])
            self.vtmon1.start()
            self.vtmon2.start()
            self.vtmon3.start()
            self.imona .start()
            self.imonb .start()

        @self.command()
        def update_env():
            self.i2cmux.setPort(i2cSwitchPort['LocalBus'])
            d = self.vtmon1.mon()
            self.local12v.set( d['ain'][3]*6. )
            self.edge12v .set( d['ain'][6]*6. )
            self.aux12v  .set( d['ain'][7]*6. )

            d = self.vtmon2.mon()
            self.boardTemp.set( d['Tint'] )
            self.local1_8v.set( d['ain'][6] )

            d = self.vtmon3.mon()
            self.fmc12v   .set( d['ain'][2]*6. )
            self.local2_5v.set( d['ain'][6]*2. )
            self.local3_3v.set( d['ain'][7]*2. )

            self.fmcPower  .set(self.imona.power_W())
            self.totalPower.set(self.imonb.power_W())

        @self.command()
        def setClk_119M():
            self.i2cmux.setPort(i2cSwitchPort['LocalBus'])
            self.clksynth.setTimingClk('_119M')

        @self.command()
        def setClk_186M():
            self.i2cmux.setPort(i2cSwitchPort['LocalBus'])
            self.clksynth.setTimingClk('_186M')

        @self.command()
        def setClk_4M():
            self.i2cmux.setPort(i2cSwitchPort['LocalBus'])
            self.clksynth.setTimingClk('_4M')

        @self.command(value='')
        def set_i2c_mux(arg):
            self.i2cmux.setPort(i2cSwitchPort[arg])
            
