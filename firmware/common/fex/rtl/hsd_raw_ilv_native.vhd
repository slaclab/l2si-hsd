-- ==============================================================
-- RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2016.4
-- Copyright (C) 1986-2017 Xilinx, Inc. All Rights Reserved.
-- 
-- ===========================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;

library surf;
use surf.StdRtlPkg.all;
use surf.AxiLitePkg.all;
use work.FmcPkg.all;

entity hsd_raw_ilv_native is
generic (
    ILV_G                    : INTEGER := 4;
    DEBUG_G                  : boolean := false );
port (
    ap_clk   : IN STD_LOGIC;
    ap_rst_n : IN STD_LOGIC;
    sync     : IN  STD_LOGIC;
    x        : in  AdcWordArray(ILV_G*ROW_SIZE-1 downto 0);
    tin      : in  Slv2Array   (      ROW_SIZE-1 downto 0);
    y        : out Slv16Array  (ILV_G*(ROW_SIZE+1)-1 downto 0);
    tout     : out Slv2Array   (      ROW_SIZE   downto 0);
    yv       : out slv         (      ROW_IDXB-1 downto 0);
    axilReadMaster  : in  AxiLiteReadMasterType;
    axilReadSlave   : out AxiLiteReadSlaveType;
    axilWriteMaster : in  AxiLiteWriteMasterType;
    axilWriteSlave  : out AxiLiteWriteSlaveType );
end;


architecture behav of hsd_raw_ilv_native is

  type RegType is record
    count      : slv(12 downto 0);
    count_last : slv(12 downto 0);
    nopen      : slv(4 downto 0);
    lskip      : sl;
    y          : Slv16Array(ILV_G*ROW_SIZE+ILV_G-1 downto 0);
    t          : Slv2Array (      ROW_SIZE   downto 0);
    yv         : slv       (      ROW_IDXB-1 downto 0);
  end record;
  
  constant REG_INIT_C : RegType := (
    count      => (others=>'0'),
    count_last => (others=>'0'),
    nopen      => (others=>'0'),
    lskip      => '0',
    y          => (others=>(others=>'0')),
    t          => (others=>(others=>'0')),
    yv         => (others=>'0'));

  signal r    : RegType := REG_INIT_C;
  signal r_in : RegType;

  component ila_0
    port ( clk     : in sl;
           probe0  : in slv(255 downto 0) );
  end component;

  signal tin0, tout0 : slv(ROW_SIZE-1 downto 0);

  constant ANY_SKIP_G : boolean := true;
  
begin

  axilReadSlave  <= AXI_LITE_READ_SLAVE_EMPTY_OK_C;
  axilWriteSlave <= AXI_LITE_WRITE_SLAVE_EMPTY_OK_C;
  
  comb : process ( sync, r, x, tin ) is
    variable v      : RegType;
    variable tsum   : slv(1 downto 0);
    variable dcount : slv(12 downto 0);
    constant ILVB   : integer := bitSize(ILV_G-1);
  begin
    v := r;

    -- default response
    for i in 0 to ILV_G*ROW_SIZE-1 loop
      v.y(i) := resize(x(i),16);
    end loop;
    for i in 0 to ILV_G-1 loop
      v.y(i+ILV_G*ROW_SIZE) := x"8000";
    end loop;
    v.t           := "00" & tin;
    
    tsum   := "00";
    for i in 0 to ROW_SIZE-1 loop
      tsum := tsum or tin(i);
    end loop;

    --  samples/ILV_G since last readout
    dcount := r.count - r.count_last;

    if r.lskip = '1' then
        -- skip to the first position
      v.y(0) := '1' & resize(dcount-1,15-ILVB) & toSlv(0,ILVB);
      for i in 1 to ILV_G-1 loop
        v.y(i) := '1' & toSlv(0,15);
      end loop;
      v.t(0) := "00";
      for i in 0 to ROW_SIZE-1 loop
        for j in 0 to ILV_G-1 loop
          v.y((i+1)*ILV_G+j) := resize(x(i*ILV_G+j),16);
        end loop;
        v.t(i+1) := tin(i);
      end loop;

      if tsum(0) = '1' then
        v.yv         := toSlv(ROW_SIZE+1,ROW_IDXB);
        v.count_last := r.count+ROW_SIZE-1;
        v.lskip      := '0';
      elsif dcount(dcount'left) = '1' then
        if ANY_SKIP_G then --  We don't really need this character (no gate is open)
          v.yv         := toSlv(1,ROW_IDXB);
        else
          v.yv         := toSlv(0,ROW_IDXB);
        end if;       
        v.count_last := r.count;
      else
        v.yv         := toSlv(0,ROW_IDXB);
      end if;
    elsif r.nopen /= 0 then
      v.yv         := toSlv(ROW_SIZE,ROW_IDXB);
      v.count_last := r.count+ROW_SIZE-1;
    else
      v.yv    := toSlv(0,ROW_IDXB);
      v.lskip := '1';
    end if;

    if tsum = "01" then
      v.nopen := r.nopen+1;
    elsif tsum = "10" then
      v.nopen := r.nopen-1;
    end if;

    v.count := r.count + ROW_SIZE;

    y    <= r.y;
    yv   <= r.yv;
    tout <= r.t;
    
    if sync = '1' then
      v := REG_INIT_C;
    end if;

    r_in <= v;
  end process comb;

  seq : process ( ap_clk ) is
  begin
    if rising_edge(ap_clk) then
      r <= r_in;
    end if;
  end process seq;

end behav;
