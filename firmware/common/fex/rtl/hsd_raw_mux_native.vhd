-- ==============================================================
-- RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2016.4
-- Copyright (C) 1986-2017 Xilinx, Inc. All Rights Reserved.
-- 
-- ===========================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;

library surf;
use surf.StdRtlPkg.all;
use surf.AxiLitePkg.all;
use work.FmcPkg.all;

entity hsd_raw_mux_native is
generic (
    ILV_G                    : INTEGER := 4;
    DEBUG_G                  : boolean := false );
port (
    ap_clk   : IN STD_LOGIC;
    ap_rst_n : IN STD_LOGIC;
    sync     : IN  STD_LOGIC;
    x        : in  AdcWordArray(ILV_G*ROW_SIZE-1 downto 0);
    tin      : in  Slv2Array   (      ROW_SIZE-1 downto 0);
    y        : out Slv16Array  (ILV_G*(ROW_SIZE+1)-1 downto 0);
    tout     : out Slv2Array   (      ROW_SIZE   downto 0);
    yv       : out slv         (      ROW_IDXB-1 downto 0);
    axilReadMaster  : in  AxiLiteReadMasterType;
    axilReadSlave   : out AxiLiteReadSlaveType;
    axilWriteMaster : in  AxiLiteWriteMasterType;
    axilWriteSlave  : out AxiLiteWriteSlaveType );
end;


architecture behav of hsd_raw_mux_native is

  constant ILVB   : integer := bitSize(ILV_G-1);

  type RegType is record
    chan       : slv(ILVB-1 downto 0);
    count      : slv(12 downto 0);
    count_last : slv(12 downto 0);
    nopen      : slv(4 downto 0);
    lskip      : sl;
    y          : Slv16Array(ROW_SIZE-1 downto 0);
    t          : Slv2Array (ROW_SIZE   downto 0);
    yv         : slv       (ROW_IDXB-1 downto 0);
    readSlave  : AxiLiteReadSlaveType;
    writeSlave : AxiLiteWriteSlaveType;
  end record;
  
  constant REG_INIT_C : RegType := (
    chan       => (others=>'0'),
    count      => (others=>'0'),
    count_last => (others=>'0'),
    nopen      => (others=>'0'),
    lskip      => '0',
    y          => (others=>(others=>'0')),
    t          => (others=>(others=>'0')),
    yv         => (others=>'0'),
    readSlave  => AXI_LITE_READ_SLAVE_INIT_C,
    writeSlave => AXI_LITE_WRITE_SLAVE_INIT_C );

  signal r    : RegType := REG_INIT_C;
  signal r_in : RegType;

  component ila_0
    port ( clk     : in sl;
           probe0  : in slv(255 downto 0) );
  end component;

  signal tin0, tout0 : slv(ROW_SIZE-1 downto 0);

  constant ANY_SKIP_G : boolean := true;
  
begin

  axilWriteSlave <= r.writeSlave;
  axilReadSlave  <= r.readSlave;
  
  comb : process ( sync, r, x, tin, axilWriteMaster, axilReadMaster ) is
    variable v      : RegType;
    variable ep     : AxiLiteEndPointType;
    variable tsum   : slv(1 downto 0);
    variable dcount : slv(12 downto 0);
  begin
    v := r;

    -- AxiLite accesses
    axiSlaveWaitTxn( ep,
                     axilWriteMaster, axilReadMaster,
                     v.writeSlave, v.readSlave );

    v.readSlave.rdata := (others=>'0');
      
    axiSlaveRegister ( ep, x"10", 0, v.chan  );
    
    axiSlaveDefault( ep, v.writeSlave, v.readSlave );

    -- default response
    v.t := (others=>"00");
    for i in 0 to ROW_SIZE-1 loop
      v.t(i/ILV_G) := v.t(i/ILV_G) or tin(i);
      v.y(i) := resize(x(i*ILV_G+conv_integer(r.chan)),16);
    end loop;
    
    tsum   := "00";
    for i in 0 to ROW_SIZE-1 loop
      tsum := tsum or tin(i);
    end loop;

    --  samples/ILV_G since last readout
    dcount := r.count - r.count_last;

    if r.lskip = '1' then
      -- ignore skips

      if tsum(0) = '1' then
        v.yv         := toSlv(ROW_SIZE/ILV_G,ROW_IDXB);
        v.count_last := r.count+ROW_SIZE-1;
        v.lskip      := '0';
      elsif dcount(dcount'left) = '1' then
        v.yv         := toSlv(0,ROW_IDXB);
        v.count_last := r.count;
      else
        v.yv         := toSlv(0,ROW_IDXB);
      end if;
    elsif r.nopen /= 0 then
      v.yv         := toSlv(ROW_SIZE/ILV_G,ROW_IDXB);
      v.count_last := r.count+ROW_SIZE-1;
    else
      v.yv    := toSlv(0,ROW_IDXB);
      v.lskip := '1';
    end if;

    if tsum = "01" then
      v.nopen := r.nopen+1;
    elsif tsum = "10" then
      v.nopen := r.nopen-1;
    end if;

    v.count := r.count + ROW_SIZE;

    y(r.y'range) <= r.y;
    yv   <= r.yv;
    tout <= r.t;
    
    if sync = '1' then
      v := REG_INIT_C;
    end if;

    r_in <= v;
  end process comb;

  seq : process ( ap_clk ) is
  begin
    if rising_edge(ap_clk) then
      r <= r_in;
    end if;
  end process seq;

end behav;
